{"version":3,"sources":["object-uploader.js"],"names":["ObjectUploader","client","bucketName","objectName","partSize","metaData","callback","emptyStream","partNumber","oldParts","etags","id","on","err","chunk","encoding","method","headers","Object","assign","length","md5digest","enableSHA256","Crypto","createHash","update","digest","toString","options","query","makeRequest","response","result","etag","versionId","process","nextTick","once","_transform","findUploadId","emit","initiateNewMultipartUpload","listParts","reduce","prev","item","part","oldPart","push","querystring","stringify","uploadId","replace","completeMultipartUpload","Transform"],"mappings":"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","sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Transform } from 'stream'\nimport Crypto from 'crypto'\nimport * as querystring from 'querystring'\nimport { getVersionId, sanitizeETag } from \"./helpers\"\n\n// We extend Transform because Writable does not implement ._flush().\nexport default class ObjectUploader extends Transform {\n  constructor(client, bucketName, objectName, partSize, metaData, callback) {\n    super()\n    this.emptyStream = true\n    this.client = client\n    this.bucketName = bucketName\n    this.objectName = objectName\n    // The size of each multipart, chunked by BlockStream2.\n    this.partSize = partSize\n    // This is the metadata for the object.\n    this.metaData = metaData\n\n    // Call like: callback(error, {etag, versionId}).\n    this.callback = callback\n\n    // We need to keep track of what number chunk/part we're on. This increments\n    // each time _write() is called. Starts with 1, not 0.\n    this.partNumber = 1\n\n    // A list of the previously uploaded chunks, for resuming a file upload. This\n    // will be null if we aren't resuming an upload.\n    this.oldParts = null\n\n    // Keep track of the etags for aggregating the chunks together later. Each\n    // etag represents a single chunk of the file.\n    this.etags = []\n\n    // This is for the multipart upload request — if null, we're either not initiated\n    // yet or we're flushing in one packet.\n    this.id = null\n\n    // Handle errors.\n    this.on('error', err => {\n      callback(err)\n    })\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.emptyStream = false\n    let method = 'PUT'\n    let headers = Object.assign({}, this.metaData, {'Content-Length': chunk.length})\n    let md5digest = ''\n\n    // Calculate and set Content-MD5 header if SHA256 is not set.\n    // This will happen only when there is a secure connection to the s3 server.\n    if (!this.client.enableSHA256) {\n      md5digest = Crypto.createHash('md5').update(chunk).digest()\n      headers['Content-MD5'] = md5digest.toString('base64')\n    }\n    // We can flush the object in one packet if it fits in one chunk. This is true\n    // if the chunk size is smaller than the part size, signifying the end of the\n    // stream.\n    if (this.partNumber == 1 && chunk.length < this.partSize) {\n      // PUT the chunk in a single request — use an empty query.\n      let options = {\n        method, headers,\n        query: '',\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      }\n\n      this.client.makeRequest(options, chunk, 200, '', true, (err, response) => {\n        if (err) return callback(err)\n        let result = {\n          etag: sanitizeETag(response.headers.etag),\n          versionId :getVersionId(response.headers)\n        }\n        // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n        response.on('data', () => {})\n\n        // Give the etag back, we're done!\n\n        process.nextTick(() => {\n          this.callback(null, result)\n        })\n\n        // Because we're sure the stream has ended, allow it to flush and end.\n        callback()\n      })\n\n      return\n    }\n\n    // If we aren't flushing in one packet, we need to initiate the multipart upload,\n    // if it hasn't already been done. The write will be buffered until the upload has been\n    // initiated.\n    if (this.id === null) {\n      this.once('ready', () => {\n        this._transform(chunk, encoding, callback)\n      })\n\n      // Check for an incomplete previous upload.\n      this.client.findUploadId(this.bucketName, this.objectName, (err, id) => {\n        if (err) return this.emit('error', err)\n\n        // If no upload ID exists, initiate a new one.\n        if (!id) {\n          this.client.initiateNewMultipartUpload(this.bucketName, this.objectName, this.metaData, (err, id) => {\n            if (err) return callback(err)\n\n            this.id = id\n\n            // We are now ready to accept new chunks — this will flush the buffered chunk.\n            this.emit('ready')\n          })\n\n          return\n        }\n\n        this.id = id\n\n        // Retrieve the pre-uploaded parts, if we need to resume the upload.\n        this.client.listParts(this.bucketName, this.objectName, id, (err, etags) => {\n          if (err) return this.emit('error', err)\n\n          // It is possible for no parts to be already uploaded.\n          if (!etags) etags = []\n\n          // oldParts will become an object, allowing oldParts[partNumber].etag\n          this.oldParts = etags.reduce(function(prev, item) {\n            if (!prev[item.part]) {\n              prev[item.part] = item\n            }\n            return prev\n          }, {})\n\n          this.emit('ready')\n        })\n      })\n\n      return\n    }\n\n    // Continue uploading various parts if we have initiated multipart upload.\n    let partNumber = this.partNumber++\n\n    // Check to see if we've already uploaded this chunk. If the hash sums match,\n    // we can skip to the next chunk.\n    if (this.oldParts) {\n      let oldPart = this.oldParts[partNumber]\n\n      //Calulcate the md5 hash, if it has not already been calculated.\n      if(!md5digest) {\n        md5digest = Crypto.createHash('md5').update(chunk).digest()\n      }\n\n      if (oldPart && md5digest.toString('hex') === oldPart.etag) {\n        // The md5 matches, the chunk has already been uploaded.\n        this.etags.push({part: partNumber, etag: oldPart.etag})\n\n        callback()\n        return\n      }\n    }\n\n    // Write the chunk with an uploader.\n    let query = querystring.stringify({\n      partNumber: partNumber,\n      uploadId: this.id\n    })\n\n    let options = {\n      method, query, headers,\n      bucketName: this.bucketName,\n      objectName: this.objectName\n    }\n\n    this.client.makeRequest(options, chunk, 200, '', true, (err, response) => {\n      if (err) return callback(err)\n\n      // In order to aggregate the parts together, we need to collect the etags.\n      let etag = response.headers.etag\n      if (etag)\n        etag = etag.replace(/^\"/, '').replace(/\"$/, '')\n\n      this.etags.push({part: partNumber, etag})\n\n      // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n      response.on('data', () => {})\n\n      // We're ready for the next chunk.\n      callback()\n    })\n  }\n\n  _flush(callback) {\n    if (this.emptyStream) {\n      let method = 'PUT'\n      let headers = Object.assign({}, this.metaData, {'Content-Length': 0})\n      let options = {\n        method, headers,\n        query: '',\n        bucketName: this.bucketName,\n        objectName: this.objectName\n      }\n\n      this.client.makeRequest(options, '', 200, '', true, (err, response) => {\n        if (err) return callback(err)\n\n        let result = {\n          etag: sanitizeETag(response.headers.etag),\n          versionId: getVersionId(response.headers)\n        }\n\n        // Ignore the 'data' event so that the stream closes. (nodejs stream requirement)\n        response.on('data', () => {})\n\n        // Give the etag back, we're done!\n        process.nextTick(() => {\n          this.callback(null, result)\n        })\n\n        // Because we're sure the stream has ended, allow it to flush and end.\n        callback()\n      })\n\n      return\n    }\n    // If it has been uploaded in a single packet, we don't have to do anything.\n    if (this.id === null) {\n      return\n    }\n\n    // This is called when all of the chunks uploaded successfully, thus\n    // completing the multipart upload.\n    this.client.completeMultipartUpload(this.bucketName, this.objectName, this.id,\n                                        this.etags, (err, etag) => {\n                                          if (err) return callback(err)\n\n                                          // Call our callback on the next tick to allow the streams infrastructure\n                                          // to finish what its doing before we continue.\n                                          process.nextTick(() => {\n                                            this.callback(null, etag)\n                                          })\n\n                                          callback()\n                                        })\n  }\n}\n"],"file":"object-uploader.js"}